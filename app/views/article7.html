<div class="row">
  <div class="article">
    <div class="title">
      Общая характеристика инструментальных средств разработки программ, состояние и перспективы.
    </div>
    <div class="subtitle">
      Современные языки программирования
    </div>
    <div class="paragraph">
      Наверное, нет такого программиста, который не хотел бы создать свой собственный язык программирования: самый
      быстрый и надежный, самый удобный и простой. Именно поэтому за всю свою "компьютерную" историю человек придумал
      множество самых разных языков программирования. Одни из них послужив своим создателям, канули в "лету", другие,
      получив признание программистов всего мира, существуют до сих пор.
    </div>
    <div class="paragraph">
      Но тщеславие программистов не единственная причина возникновения новых языков программирования. Время не стоит на
      месте, развивается и наука и технологии, то, что ещё вчера казалось пределом научно–технического прогресса,
      сегодня уже вчерашний день.
    </div>
    <div class="paragraph">
      В настоящее время перед программистами ставятся задачи по созданию систем обработки и хранения информации, которые
      ещё двадцать лет назад казались невозможными. Появляются устройства и технологии, требующие принципиально новых
      подходов к программированию. Развитие Интернета предоставляет новые, ещё до конца не освоенные возможности по
      созданию распределённых сетевых технологий.
    </div>
    <div class="paragraph">
      Всё это служит благодатной почвой для создания новых языков программирования, отвечающих всем современным задачам,
      использующих новые принципы программирования и позволяющих решать актуальные проблемы.
    </div>
    <div class="paragraph">
      Не смотря на огромное множество языков программирования, лишь немногие из них получили широкую известность и
      признание программистов. Для того, что бы определить самые популярные языки программирования воспользуемся данными
      голландской компании "TIOBE Software BV" в первую очередь известной своим регулярно рассчитываемым рейтингом
      популярности языков программирования. Несмотря на многолетние споры, относительно качества и достоверности
      рейтинга, других источников позволяющих хоть как-то оценить тенденции в развитии языков программирования на
      сегодняшний день нет.
    </div>
    <div class="paragraph callout">
      По данным компании "TIOBE Software BV" десять самых популярных языков программирования на декабрь 2010 года
      представлены в таблице.
    </div>
    <div class="paragraph">
      Рейтинг языков программирования
    </div>
    <table class="table table-bordered table-striped">
      <thead>
      <tr>
        <th class="col-md-4">№</th>
        <th class="col-md-8"> Язык программирования</th>
        <th class="col-md-8"> Рейтинг</th>
        <th class="col-md-8"> Последний релиз</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>1</td>
        <td>Java</td>
        <td>17.999 %</td>
        <td>12.11.2010</td>
      </tr>
      <tr>
        <td>2</td>
        <td>C</td>
        <td>16.076 %</td>
        <td>16.12.2010</td>
      </tr>
      <tr>
        <td>3</td>
        <td>C++</td>
        <td>9.014 %</td>
        <td>22.07.2009</td>
      </tr>
      <tr>
        <td>4</td>
        <td>PHP</td>
        <td>7.511 %</td>
        <td>22.06.2010</td>
      </tr>
      <tr>
        <td>5</td>
        <td>C#</td>
        <td>6.687 %</td>
        <td>12.04.2010</td>
      </tr>
      <tr>
        <td>6</td>
        <td>Python</td>
        <td>6.482 %</td>
        <td>04.07.2010</td>
      </tr>
      <tr>
        <td>7</td>
        <td>Visual Basic</td>
        <td>5.118 %</td>
        <td>12.04.2010</td>
      </tr>
      <tr>
        <td>8</td>
        <td>Objective C</td>
        <td>3.242 %</td>
        <td>28.08.2009</td>
      </tr>
      <tr>
        <td>9</td>
        <td>Perl</td>
        <td>2.331 %</td>
        <td>12.04.2010</td>
      </tr>
      <tr>
        <td>10</td>
        <td>Delphi</td>
        <td>2.171 %</td>
        <td>04.08.2009</td>
      </tr>
      </tbody>
    </table>
    <div class="paragraph">
      Все эти языки программирования, безусловно, очень разные. Каждый из них имеет своё собственное назначение, подчас
      уникальную среду разработки, и конечно свой синтаксис и семантику.
    </div>
    <div class="paragraph">
      Сравнение языков программирования между собой, по их возможностям, по способам реализации и даже сложности
      освоения,
      задача очень сложная. Оценить удобство тех или иных семантических конструкций возможно только на реальных примерах
      и
      для каждого языка программирования можно найти задачу, для которой он подходит лучше, чем все остальные. Зачастую
      подобные сравнения выливаются в настоящие "войну" между сообществами программистов. Каждая из сторон защищает
      "свой"
      язык программировании и никак не принимает доводы другой стороны. Как правило, такие "войны" заканчиваются
      "ничьей"
      или не заканчиваются вовсе.
    </div>
    <div class="paragraph">
      Однако, рассмотрение языков программирования по общим для них всех концепциям, позволяет судить о развитии
      программирования в целом. О том, какие задачи наиболее актуальны, какими методами они решаются, и какие подходы
      для
      этого используются.
    </div>
    <div class="paragraph ">
      Рассмотрим эти языки программирования с нескольких основных позиций:

    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Какие парадигмы программирования наиболее популярны в современных языках.
      </li>
      <li class="list-group-item">
        Какие виды трансляторов применяются.
      </li>
      <li class="list-group-item">
        Какие виды типизации используются.
      </li>
    </ul>
    <div class="subtitle">
      Парадигмы программирования
    </div>
    <div class="paragraph callout">
      Парадигма – набор теорий, стандартов и методов, которые совместно представляют собой способ организации научного
      знания.
    </div>
    <div class="paragraph">
      Парадигма программирования – это совокупность идей и понятий, определяющая стиль написания программ.
    </div>
    <div class="paragraph callout">
      Парадигма программирования – модель или подход к решению проблемы.
    </div>
    <div class="paragraph">
      Парадигма, в первую очередь, определяется базовой программной единицей и самим принципом достижения модульности
      программы. В качестве этой единицы выступают определение, действие, правило, диаграмма переходов и др. сущности.
      Парадигма программирования определяет то, в каких терминах программист описывает логику программы. Например, как
      последовательность действий, в виде выражения и множества определений функций, рассматривать программу как набор
      взаимодействующих объектов.
    </div>
    <div class="paragraph">
      Важно отметить, что парадигма программирования не определяется однозначно языком программирования – многие
      современные языки программирования являются мультипарадигменными, то есть допускают использование различных
      парадигм.
    </div>
    <div class="paragraph">
      На сегодняшний день самые известные модели программирования:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Императивная
      </li>
      <li class="list-group-item">
        – Процедурное программирование
      </li>
      <li class="list-group-item">
        Декларативная
      </li>
      <li class="list-group-item">
        – Функциональное программирование
      </li>
      <li class="list-group-item">
        – Логическое программирование
      </li>
      <li class="list-group-item">
        Структурная
      </li>
      <li class="list-group-item">
        – Модульное программирование
      </li>
      <li class="list-group-item">
        – Объектно-ориентированное программирование
      </li>
      <li class="list-group-item">
        Метапрограммирование
      </li>
      <li class="list-group-item">
        – Генерация кода
      </li>
      <li class="list-group-item">
        – Самомодифицирующийся код
      </li>
    </ul>
    <div class="subtitle">
      Императивная модель
    </div>
    <div class="paragraph">
      Императивная модель – это парадигма программирования, характеризующаяся принципом последовательного изменения
      состояния вычислителя пошаговым образом. При этом управление изменениями полностью определено и полностью
      контролируемо.
    </div>
    <div class="paragraph callout">
      Один из подходов реализующих императивную модель программирования – Процедурное программирование.
    </div>
    <div class="paragraph">
      При этом программа состоит из последовательности операторов (инструкций), задающих процедуру решения задачи.
      Основным является оператор присваивания, служащий для изменения содержимого областей памяти. Концепция памяти как
      хранилища значений, содержимое которого может обновляться операторами программы, является фундаментальной в
      императивном программировании.Императивное программирование наиболее пригодно для реализации небольших подзадач,
      где
      очень важна скорость исполнения на современных компьютерах.
    </div>
    <div class="subtitle">
      Декларативная модель
    </div>
    <div class="paragraph callout">
      Декларативная модель – это парадигма программирования, характеризующаяся принципом при котором описывается каково
      нечто, а не как его создать.
    </div>
    <div class="paragraph">
      Есть несколько подходов реализующих декларативную модель программирования:
    </div>
    <div class="paragraph callout">
      Функциональное программирование – при котором процесс вычисления трактуется как вычисление значений функций в
      математическом понимании последних. Функциональное программирование предполагает обходиться вычислением
      результатов
      функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы.
      Соответственно, не предполагает оно и изменяемость этого состояния.
    </div>
    <div class="paragraph">
      На практике отличие математической функции от понятия "функции" в императивном программировании заключается в том,
      что императивные функции могут опираться не только на аргументы, но и на состояние внешних по отношению к функции
      переменных, а также иметь побочные эффекты и менять состояние внешних переменных.
    </div>
    <div class="paragraph callout">
      Логическое программирование – основанное на автоматическом доказательстве теорем, с использованием механизмов
      логического вывода информации с использованием заданных фактов и правил вывода, основанных на формальных
      исчислениях. Логическое программирование основано на теории и аппарате математической логики с использованием
      математических принципов резолюций.
    </div>
    <div class="subtitle">
      Структурная модель
    </div>
    <div class="paragraph">
      Структурное программирование – это парадигма программирования, в основе которой лежит представление программы в
      виде
      иерархической структуры блоков. В соответствии с данной парадигмой:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Любая программа представляет собой структуру, построенную из базовых конструкций.
      </li>
      <li class="list-group-item">
        В программе базовые конструкции могут быть вложены друг в друга произвольным образом, но никаких других
        средств
        управления последовательностью выполнения операций не предусматривается.
      </li>
      <li class="list-group-item">
        Повторяющиеся фрагменты программы (либо представляющие собой логически целостные вычислительные блоки) могут
        оформляться в виде т. н. подпрограмм (процедур или функций).
      </li>
    </ul>

    <div class="paragraph callout">
      Модульное программирование – основанное на разбиении программы на независимые модули, каждый из которых
      компилируется отдельно от остальных. Такая модульность программного кода позволяет значительно уменьшить время
      перекомпиляции при изменениях, вносимых лишь в небольшое количество исходных файлов, и упрощает групповую
      разработку.
    </div>
    <div class="paragraph callout">
      Объектно–ориентированное программирование (или объектное) – состоит в описании структуры и поведения
      проектируемой
      системы, то есть, фактически, определяет: из каких частей состоит система и в чём состоит ответственность каждой
      из частей, при этом основными концепциями являются понятия объектов и классов.
    </div>
    <div class="paragraph callout">
      Класс – это тип, описывающий устройство объектов. Это в чистом виде абстрактный тип данных, создаваемый
      программистом.
    </div>
    <div class="paragraph callout">
      Объект – сущность в адресном пространстве вычислительной системы, появляющаяся при создании экземпляра класса.
    </div>
    <div class="paragraph">
      Понятие "класс" подразумевает некоторое поведение и способ представления. Понятие "объект" подразумевает нечто,
      что обладает определённым поведением и способом представления.
    </div>
    <div class="subtitle">
      Метапрограммирование
    </div>
    <div class="paragraph">
      Метапрограммирование – это парадигма программирования, основанная на создании программ, которые порождают другие
      программы как результат своей работы (в частности, на стадии компиляции), либо программ, которые меняют себя во
      время выполнения (самомодифицирующийся код).
    </div>
    <div class="paragraph">
      Есть несколько подходов реализующих модель метапрограммирования:
    </div>
    <div class="paragraph">
      Генерация кода – при этом подходе код программы не пишется вручную, а создается автоматически
      программой-генератором на основе другой, более простой программы. Реализуется двумя основными методами:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Шаблоны. Решают задачу, если соблюдение "правил" сводится к вставке в программу повторяющихся (или почти
        повторяющихся) кусков кода. Помимо этого, обладают еще рядом достоинств: например, помогают повторному
        использованию.
      </li>
      <li class="list-group-item">
        Внешне-языковые средства. Применяются в случаях, если простых средств вроде шаблонов недостаточно. Язык
        генератора составляется так, чтобы автоматически или с минимальными усилиями со стороны программиста
        реализовывать правила парадигмы или необходимые специальные функции. Фактически, это – более высокоуровневый
        язык программирования, а генератор – не что иное, как транслятор. Генераторы пишутся, как правило, для
        создания специализированных программ, в которых очень значительная часть стереотипна, либо для реализации
        сложных парадигм.
      </li>
    </ul>
    <div class="paragraph">
      Основные парадигмы и подходы к решению задач в современных языках программирования представлены в таблице.
    </div>
    <div class="paragraph">
      Парадигмы и подходы языков программирования
    </div>
    <table class="table table-bordered table-striped">
      <thead>
      <tr>
        <th class="col-md-8"> Язык программирования</th>
        <th class="col-md-8"> Парадигмы программирования</th>
        <th class="col-md-8"> Основные подходы программирования</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>Java</td>
        <td>императивная<br>структурная</td>
        <td>объектно-ориентированный</td>
      </tr>
      <tr>
        <td>C</td>
        <td>императивная</td>
        <td>процедурный</td>
      </tr>
      <tr>
        <td>C++</td>
        <td>мультипарадигмальный<br>
          метапрограммирование
        </td>
        <td>процедурный<br>
          объектно-ориентированный
        </td>
      </tr>
      <tr>
        <td>PHP</td>
        <td>мультипарадигмальный</td>
        <td>процедурный<br>
          объектно-ориентированный
        </td>
      </tr>
      <tr>
        <td>C#</td>
        <td>мультипарадигмальный
          <br>императивная
        </td>
        <td>процедурный<br>объектно-ориентированный</td>
      </tr>
      <tr>
        <td>Python</td>
        <td>императивная<br>
          <br>декларативная<br>структурная
        </td>
        <td>процедурный<br>
          функциональный<br>
          объектно-ориентированный
        </td>
      </tr>
      <tr>
        <td>Visual Basic</td>
        <td>императивная<br>
          структурная
        </td>
        <td>процедурный<br>
          объектно-ориентированный
        </td>
      </tr>
      <tr>
        <td>Objective C</td>
        <td>мультипарадигмальный</td>
        <td>процедурный<br>
          объектно-ориентированный
        </td>
      </tr>
      <tr>
        <td>Perl</td>
        <td>мультипарадигмальный<br> декларативная</td>
        <td>функциональный<br>объектно-ориентированный</td>
      </tr>
      <tr>
        <td>Delphi</td>
        <td>императивная<br>структурная</td>
        <td>процедурный<br>
          объектно-ориентированный
        </td>
      </tr>


      </tbody>
    </table>
    <div class="paragraph">
      Современные языки программирования не ограничиваются какой-то одной парадигмой, а используют их несколько или даже
      являются мультипарадигмальными. Это обусловлено стремлением разработчиков расширить области применения языка,
      сделать его языком общего назначения, а не ориентированным на решение узкого круга задач.
    </div>
    <div class="paragraph">
      Использование почти всеми языками объектно-ориентированного подхода наряду с "классическим" процедурным,
      обусловлено
      возрастающей сложностью современных задач. Создание больших распределенных систем просто не мыслимо без создания
      структурной модели, а работа с объектами, в любых их проявлениях, значительно облегчает разработку и отладку таких
      систем.
    </div>
    <div class="subtitle">
      Трансляторы
    </div>
    <div class="paragraph">
      Поскольку текст, записанный на языке программирования, непонятен компьютеру, то требуется перевести его на
      машинный
      код. Такой перевод программы с языка программирования на язык машинных кодов называется трансляцией, а выполняется
      она специальными программами – трансляторами.
    </div>
    <div class="paragraph callout">
      Транслятор – обслуживающая программа, преобразующая исходную программу, предоставленную на входном языке
      программирования, в рабочую программу, представленную на объектном языке.
    </div>
    <div class="paragraph">
      В настоящее время трансляторы разделяются на две основные группы: компиляторы и интерпретаторы.
    </div>
    <div class="subtitle">
      Компилятор
    </div>
    <div class="paragraph">
      Компилятор – это обслуживающая программа, выполняющая трансляцию на машинный язык программы, записанной на
      исходном
      языке программирования. Компилятор обеспечивает преобразование программы с одного языка на другой (чаще всего, в
      язык конкретного компьютера). Вместе с тем, команды исходного языка значительно отличаются по организации и
      мощности
      от команд машинного языка. Существуют языки, в которых одна команда исходного языка транслируется в 7–10 машинных
      команд. Однако есть и такие языки, в которых каждой команде может соответствовать 100 и более машинных команд.
      Кроме
      того, в исходных языках достаточно часто используется строгая типизация данных, осуществляемая через их
      предварительное описание. Программирование может опираться не на кодирование алгоритма, а на тщательное
      обдумывание
      структур данных или классов. Процесс трансляции с таких языков обычно называется компиляцией, а исходные языки
      обычно относятся к языкам программирования высокого уровня (или высокоуровневым языкам).
    </div>
    <div class="subtitle">
      Интерпретатор
    </div>
    <div class="paragraph callout">
      Интерпретатор – программа или устройство, осуществляющее пооператорную трансляцию и выполнение исходной программы.
      Интерпретатор не порождает на выходе программу на машинном языке. Распознав команду исходного языка, он тут же
      выполняет ее.
    </div>
    <div class="paragraph">
      <b>Простой интерпретатор</b> – анализирует и тут же выполняет (собственно интерпретация) программу покомандно (или
      построчно), по мере поступления исходного кода на вход интерпретатора. Достоинством такого подхода является
      мгновенная реакция. Недостаток – такой интерпретатор обнаруживает ошибки в тексте программы только при попытке
      выполнения команды (или строки) с ошибкой.
    </div>
    <div class="paragraph">
      <b>Интерпретатор компилирующего типа</b> – это система из компилятора, переводящего исходный код программы в
      промежуточное
      представление, например, в байт-код или p-код, и собственно интерпретатора, который выполняет полученный
      промежуточный код (так называемая виртуальная машина). Достоинством таких систем является большее быстродействие
      выполнения программ (за счёт выноса анализа исходного кода в отдельный, разовый проход, и минимизации этого
      анализа
      в интерпретаторе). Недостатки – большее требование к ресурсам и требование на корректность исходного кода.
    </div>
    <div class="paragraph">
      Достоинства интерпретаторов:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Большая переносимость интерпретируемых программ программа будет работать на любой платформе, на которой есть
        соответствующий интерпретатор.
      </li>
      <li class="list-group-item">
        Как правило, более совершенные и наглядные средства диагностики ошибок в исходных кодах.
      <li class="list-group-item">
        Упрощение отладки исходных кодов программ. Интерпретатор позволяет начать обработку данных после написания
        даже
        одной команды.
      </li>
      <li class="list-group-item">
        Меньшие размеры кода по сравнению с машинным кодом, полученным после обычных компиляторов.
      </li>
    </ul>
    <div class="paragraph">
      Недостатки интерпретаторов:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Интерпретируемая программа не может выполняться отдельно без программы–интерпретатора. Сам интерпретатор при
        этом может быть не очень компактным.
      </li>
      <li class="list-group-item">
        Интерпретируемая программа выполняется медленнее, поскольку промежуточный анализ исходного кода и планирование
        его выполнения требуют дополнительного времени в сравнении с непосредственным исполнением машинного кода, в
        который мог бы быть скомпилирован исходный код.
      </li>
      <li class="list-group-item">
        Практически отсутствует оптимизация кода, что приводит к дополнительным потерям в скорости работы
        интерпретируемых программ.
      </li>
    </ul>
    <div class="paragraph">
      Таблица – Трансляторы современных языков программирования
    </div>
    <table class="table table-bordered table-striped">
      <thead>
      <tr>
        <th class="col-md-8"> Язык программирования</th>
        <th class="col-md-8"> Транслятор</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>Java</td>
        <td>компиляция в байт-код интерпретатор</td>
      </tr>
      <tr>
        <td>C</td>
        <td>компилятор</td>
      </tr>
      <tr>
        <td>C++</td>
        <td>компилятор</td>
      </tr>
      <tr>
        <td>PHP</td>
        <td>компиляция в байт-код интерпретатор</td>
      </tr>
      <tr>
        <td>C#</td>
        <td>компиляция в MSIL-код интерпретатор</td>
      </tr>
      <tr>
        <td>Python</td>
        <td>компиляция в байт-код интерпретатор</td>
      </tr>
      <tr>
        <td>Visual Basic</td>
        <td>компиляция в MSIL-код интерпретатор, компилятор</td>
      </tr>
      <tr>
        <td>Objective C</td>
        <td>компилятор</td>
      </tr>
      <tr>
        <td>Perl</td>
        <td>компиляция в байт-код интерпретатор</td>
      </tr>
      <tr>
        <td>Delphi</td>
        <td>компилятор</td>
      </tr>
      </tbody>
    </table>

    <div class="paragraph">
      Современные языки программирования используют в равной степени компиляцию и интерпретацию.
    </div>
    <div class="paragraph">
      Широкое использование компиляторов обусловлено большой скоростью работы программ, а также возможность использовать
      полностью все возможности конкретных платформ и создание "машинно-зависимых" участков кода и программ.
    </div>
    <div class="paragraph">
      Использование интерпретации, напротив, позволяет оградить программиста от особенностей конкретных платформ, что
      наиболее востребовано в связи с развитием Интернет–технологий.
    </div>
    <div class="paragraph">
      Среди интерпретируемых языков используются в основном интерпретаторы компилирующего типа, что обусловлено
      значительным увеличением скорости работы программ в сравнении с простыми интерпретаторами. При разработке больших
      и
      сложных приложений такое увеличение скорости может быть очень существенным.
    </div>
    <div class="subtitle">
      Типизация данных
    </div>
    <div class="paragraph callout">
      Тип – относительно устойчивая и независимая совокупность элементов, которую можно выделить во всём рассматриваемом
      множестве.
    </div>
    <div class="paragraph">
      Математически тип может быть определён двумя способами:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Множеством всех значений, принадлежащим типу.
      </li>
      <li class="list-group-item">
        Предикатной функцией, определяющей принадлежность объекта к данному типу.
      </li>
    </ul>
    <div class="paragraph callout">
      Тип данных – фундаментальное понятие теории программирования. Тип данных определяет множество значений, набор
      операций, которые можно применять к таким значениям и, возможно, способ реализации хранения значений и выполнения
      операций. Любые данные, которыми оперируют программы, относятся к определённым типам.
    </div>
    <div class="paragraph">
      Типы данных различаются уже на нижних уровнях системы. Так, например, даже в Ассемблере х86 различаются типы
      "целое
      число" и "вещественное число". Это объясняется тем, что для чисел рассматриваемых типов отводятся различные объёмы
      памяти, используются различные регистры микропроцессора, а для операций с ними применяются различные команды
      Ассемблера и различные ядра микропроцессора.
    </div>
    <div class="paragraph">
      В языках программирования типы данных не всегда строго соответствуют подобным математическим типам. Например, тип
      “целое число” большинства языков программирования не соответствует принятому в математике типу “целое число”, так
      как в математике указанный тип не имеет ограничений ни сверху, ни снизу, а в языках программирования эти
      ограничения
      есть. Как правило, в языках и системах имеется множество целых типов, отличающихся допустимым диапазоном значений
      (определяемым объёмом занимаемой памяти).
    </div>
    <div class="subtitle">
      Наиболее часто используемые типы данных:
    </div>
    <div class="paragraph">
      Простые:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Перечислимый тип. Хранит значения прямо указанные в его описании.
      </li>
      <li class="list-group-item">
        Целочисленный тип. Целое число со знаком и без знака.
      </li>
      <li class="list-group-item">
        Вещественный тип. Вещественное число с запятой и с плавающей точкой.
      </li>
      <li class="list-group-item">
        Символьный тип. Хранит один символ в различных кодировках.
      </li>
      <li class="list-group-item">
        Множество. Совпадает с обычным математическим понятием множества.
      </li>
      <li class="list-group-item">
        Логический тип. Принимает два значения ложь = 0 и истина = 1.
      </li>
      <li class="list-group-item">

        Указатель. Хранит адрес в памяти, указывающий на какую–либо информацию, как правило – указатель на переменную.
      </li>
    </ul>
    <div class="paragraph">
      Составные (сложные):
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Массив. Хранит индексированный набор элементов одного типа.
      </li>
      <li class="list-group-item">
        Строковый тип. Хранит строку символов.
      </li>
      <li class="list-group-item">
        Запись (структура). Набор различных элементов (полей), хранимый как единое целое.
      </li>
      <li class="list-group-item">
        Файловый тип. Хранит только однотипные значения, доступ к которым осуществляется только последовательно.
      </li>
      <li class="list-group-item">
        Класс, метакласс, интерфейс. Абстрактные типы¬ данных в объектно–ориентированном программировании (ООП).
      </li>
    </ul>
    <div class="paragraph">
      Как уже отмечалось ранее, любой тип данных в языках программирования определяет не только множество собственных
      значений, но и набор операций, способы хранения и присваивания значений. Типы переменных и параметров должны
      совпадать
      с присваиваемыми им значениями или вызываемыми для них функциями. Для обеспечения совместимости типов переменных и
      их
      значений в языках программирования существует контроль типов (типизация) – это процесс проверки и накладывания
      ограничений на использование типов.
    </div>
    <div class="paragraph">
      Существует два вида контроля типов:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Статическая типизация – при которой переменная, параметр подпрограммы, возвращаемое значение функции связывается
        с
        типом в момент объявления и тип не может быть изменён позже. Переменная или параметр будут принимать, а функция
        возвращать значения только этого типа.
      </li>
      <li class="list-group-item">
        Динамическая типизация – при которой переменная связывается с типом в момент присваивания значения, а не в
        момент
        объявления переменной. Таким образом, в различных участках программы одна и та же переменная может принимать
        значения разных типов.
      </li>
    </ul>
    <div class="paragraph">
      Определение соответствия типов тоже является важным моментом, для этого используется следующие два подхода:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Строгая типизация – совместимость типов автоматически контролируется транслятором, она должна быть явно указана
        (наследована) при определении типа или определяется структурой самого типа (типами элементов, из которых
        построен
        составной тип).
      </li>
      <li class="list-group-item">
        Слабая типизация – совместимость типов никак транслятором не контролируется. В языках со слабой типизацией
        обычно
        используется подход под названием "утиная типизация" – когда совместимость определяется и реализуется общим
        интерфейсом доступа к данным типа.
      </li>
    </ul>
    <div class="paragraph">
      На сегодняшний день не существует единого мнения о том, какой вид типизации лучше. Рассмотрим основные достоинства
      и
      недостатки каждого вида контроля типа.
    </div>
    <div class="subtitle">
      Динамическая типизация.
    </div>
    <div class="paragraph">
      Поскольку переменная связывается с типом в момент присваивания и в ходе выполнения программы может менять свой
      тип,
      контролировать на этапе проектирования соответствие такой переменной вызываемым для нее функциям и методам
      невозможно.
      Поэтому транслятор встраивает в программу операции связанные с динамической проверкой типа. Отсюда вытекают явные
      недостатки динамической типизации:

    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Низкая скорость выполнения, связанная с динамической проверкой типа переменной перед каждым использованием.
      </li>
      <li class="list-group-item">
        Ошибки, связанные с опечатками при использовании имени переменной.
      </li>
      <li class="list-group-item">
        Масса возможностей для простых ошибок "по недосмотру", для обнаружения которых требуется, как минимум
        выполнить
        данный участок кода.
      </li>
    </ul>
    <div class="paragraph">
      В объектно–ориентированных языках не действует либо действует с ограничениями автодополнение: трудно или
      невозможно
      понять, к какому типу относится переменная, и вывести набор её полей и методов.
    </div>
    <div class="paragraph">
      Учитывая эти недостатки, для написания сложного кода нужна особая культура программирования: венгерская нотация,
      юнит–тестирование. Кроме того, в таких языках программирования отсутствует интерфейсная часть модуля (описания
      типов,
      заголовки процедур и т. д. – то, что соответствует interface–секции в Паскале и h–файлу в Си), которая сама по
      себе
      является существенной частью документации, а изредка вообще позволяет обойтись без документирования.
    </div>
    <div class="paragraph">
      В тоже время отсутствие проверки типов на этапе написания и трансляции программы ведет к возникновению некоторых
      достоинств:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Ускоряется работа компилятора – а значит, цикл "написать – проверить", что для больших проектов может быть
        существенным.
      </li>
      <li class="list-group-item">
        Повышается гибкость языка. Возможна реализация функции, вычисляющей значение выражения произвольного типа.
      </li>
      <li class="list-group-item">
        Нет дополнительных строк с вязанных с определением типа и даже с объявлением переменных.
      </li>
      <li class="list-group-item">
        Отсутствуют операции приведения типа. Соответственно, упрощается написание простых программ.
      </li>
    </ul>
    <div class="paragraph">
      В различных языках программирования динамический контроль типов реализован по-разному. Благодаря этому в некоторых
      языках недостатки этого вида типизации могут быть сведены к нулю, в прочем, как и достоинства.
    </div>
    <div class="subtitle">
      Статическая типизация.
    </div>
    <div class="paragraph">
      При таком виде контроля переменная связывается с типом в момент объявления ещё при написании программы и
      проверяется
      на соответствие при каждом её использовании программистом. При таком подходе довольно сложно найти недостатки,
      однако
      без них не обходится:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Понижается гибкость языка. Для каждого типа переменной необходима реализация собственной функции.
      </li>
      <li class="list-group-item">
        Значительно замедляется работа компилятора.
      </li>
    </ul>
    <div class="paragraph">
      В тоже время проверка типов на этапе написания и трансляции программы ведет к возникновению существенных
      достоинств:
    </div>
    <ul class="list-group">
      <li class="list-group-item">
        Высокая скорость выполнения программы, связанная с отсутствием проверки типов на этапе выполнения. "Зная" тип
        переменной транслятор может использовать для неё более простые и подходящие команды.
      </li>
      <li class="list-group-item">
        Значительно уменьшается количество ошибок связанных с некорректным использованием типа переменной:
        присваивание
        значений, операции над переменными, передача параметров в функции.
      </li>
      <li class="list-group-item">
        При явном объявлении переменных и типов повышается читабельность и понятность кода, упрощается
        документирование
        программы.
      </li>
    </ul>
    <div class="paragraph">
      Как и для динамического контроля, статический контроль типов в языках программирования реализован по-разному, что
      с
      учетом строгой или слабой типизации может налагать ряд дополнительных достоинств и недостатков.
    </div>
    <div class="paragraph">
      Типизация в языках программирования
    </div>
    <table class="table table-bordered table-striped">
      <thead>
      <tr>
        <th class="col-md-8"> Язык</th>
        <th class="col-md-8"> Типизация</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>Java</td>
        <td>статическая, строгая</td>
      </tr>
      <tr>
        <td>C</td>
        <td>статическая</td>
      </tr>
      <tr>
        <td>C++</td>
        <td>статическая</td>
      </tr>
      <tr>
        <td>PHP</td>
        <td>динамическая</td>
      </tr>
      <tr>
        <td>C#</td>
        <td>статическая, строгая</td>
      </tr>
      <tr>
        <td>Python</td>
        <td>динамическая, строгая</td>
      </tr>
      <tr>
        <td>Visual Basic</td>
        <td>динамическая</td>
      </tr>
      <tr>
        <td>Objective C</td>
        <td>статическая/динамическая</td>
      </tr>
      <tr>
        <td>Perl</td>
        <td>динамическая</td>
      </tr>
      <tr>
        <td>Delphi</td>
        <td>статическая</td>
      </tr>
      </tbody>
    </table>
    <div class="paragraph">
      В современном программировании используются языки, как со статической типизацией, так и с динамической. Следует
      отметить, что динамическая типизация больше характерна для интерпретируемых языков, а статическая типизация для
      компилируемых. Это обусловлено возможностью интерпретатора при выполнении команды анализировать типы используемых
      данных и производить приведение типов, что для скомпилированной программы выполнить гораздо сложнее.
    </div>
    <div class="paragraph">
      Однако, в языках со статической типизацией возможно использование динамических свойств по работе с типами. Для
      этого
      можно воспользоваться специальными агрегаторами (объединением, классом Variant и т.п.), которые позволят сохранить
      информацию о типе значения. При использовании подобных агрегаторов возникают накладные расходы сравнимые с
      использованием динамической типизации и некоторые неудобства в работе (явное приведение типа).
    </div>
    <div class="paragraph">
      В языках с динамической типизацией организация статической проверки типов задача сложная. Если статическая
      типизация
      поддерживается на уровне языка, то компилятор может провести проверку типов и добиться полного исключения лишних
      вычислений при применении операторов. Если такой поддержки в языке нет, то есть возможность её реализовать путем
      добавления дополнительных проверок и, следовательно, накладными расходами.
    </div>
  </div>
</div>
